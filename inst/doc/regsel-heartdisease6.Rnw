% \VignetteIndexEntry{Regularization and Variable Selection for Parametric Models (6)}
% \VignetteDepends{lqa, lpSolve, mboost, GAMBoost, glmnet, penalized}

\documentclass[a4paper]{article}

\title{Regularization and Variable Selection for Parametric Models (6)}

\begin{document}

\maketitle

                                                                                                                                                
<<echo=FALSE,eval=FALSE>>=
options(width=60)
@

<<eval=FALSE>>=
library(lqa)
library(lpSolve)
library(mboost)
library(GAMBoost)
library(glmnet)
library(penalized)
source("gdscode.txt")

source("glmOSCAR_101028.r")
load("heart.data.RData")
@

<<eval=FALSE>>=
X<-heart.data$x
X.std<-scale(X,center=TRUE,scale=TRUE)
y<-heart.data$y
p<-ncol(X)
n<-length(y)
family <- binomial()
n.fold<-10


ylab.text<-""
xlab.text<-""
Width = 6 
Height = 6 
oma.vec<-c(1,1,1,3) 
size.axis=1.4 
size.lab=1.4 
size.main=1.4 
size.right=1.2 
size.width=2.0
colour=1
@




GENERALIZED ELASTIC NET




<<eval=FALSE>>=
alpha <- 0.7
g<-5

### COEF BUILD-UPS

main.text<-"Generalized Elastic Net"
penalty.family<-genet

Plot.mat<-plot.lqa (y = y, x = X, family=family, penalty.family=penalty.family, offset.values = c (NA, alpha,g),add.MLE = FALSE, ret.true=TRUE,really.plot = FALSE,show.standardized=TRUE,gamma=0.01)
set.seed(123)
cv.result<-cv.lqa(y, X, intercept = TRUE, lambda.candidates= list(exp(seq(-10, 6, length = 60)), alpha,g), family=family, penalty.family=penalty.family, standardize = TRUE,  n.fold=n.fold, loss.func = "dev.loss", control = lqa.control(),gamma=0.01)

@
<<fig=TRUE,eval=FALSE>>=

par(oma=oma.vec,cex.axis=size.axis,cex.lab=size.lab,cex.main=size.main)
matplot(Plot.mat$s1,Plot.mat$beta.mat,type="l",ylab=ylab.text,xlab=xlab.text,main=main.text,lwd=size.width)
abline(v=sum(abs(cv.result$beta.opt[-1]%*%diag(c(sd(X)))*sqrt(n)))/sum(abs(Plot.mat$beta.mat[1, ])))
axis(4, at = Plot.mat$beta.mat[1, ], labels = colnames(X), adj = 0, las = 1,cex.axis=size.right)

@

IMPROVED CORRELATION BASED

<<eval=FALSE>>=


lambda2<-0.1



main.text<-"Improved Correlation Based"
penalty.family<-icb

Plot.mat<-plot.lqa (y = y, x = X, family=family, penalty.family=penalty.family, offset.values = c (NA, lambda2),add.MLE = FALSE, ret.true=TRUE,really.plot = FALSE,show.standardized=TRUE,gamma=0.01)
set.seed(123)
cv.result<-cv.lqa(y, X, intercept = TRUE, lambda.candidates= list(exp(seq(-10, 6, length = 60)),lambda2), family=family, penalty.family=penalty.family, standardize = TRUE,  n.fold=n.fold, loss.func = "dev.loss", control = lqa.control(),gamma=0.01)
@


<<fig=TRUE,eval=FALSE>>=

par(oma=oma.vec,cex.axis=size.axis,cex.lab=size.lab,cex.main=size.main)
matplot(Plot.mat$s1,Plot.mat$beta.mat,type="l",ylab=ylab.text,xlab=xlab.text,main=main.text,lwd=size.width)
abline(v=sum(abs(cv.result$beta.opt[-1]%*%diag(c(sd(X)))*sqrt(n)))/sum(abs(Plot.mat$beta.mat[1, ])))
axis(4, at = Plot.mat$beta.mat[1, ], labels = colnames(X), adj = 0, las = 1,cex.axis=size.right)

@













<<results=hide,eval=FALSE>>=

set.seed(123)
cv.folds <- split(sample(seq(n)), rep(1:n.fold, length = n))
fold.vec<-rep(0,n)
for(i in 1:n.fold)
{
fold.vec[cv.folds[[i]]]<-i
}
#ELASTIC NET mit penalized

Path<-matrix(0,60,p)
lambda1<-exp(seq(-10, 6, length = 60))
lambda2 = 1

for(i in 60:1)
{
Path[i,]<-coef(penalized (y,penalized=X.std/sqrt(n), lambda1 = lambda1[i], lambda2 = lambda2,model="logistic",standardize=FALSE),"penalized")
}
opt <- optL1(y,penalized=X.std/sqrt(n), lambda2 = 1,model="logistic",standardize=FALSE,fold=fold.vec)
@

<<fig=TRUE,eval=FALSE>>=

par(oma=oma.vec,cex.axis=size.axis,cex.lab=size.axis,cex.main=size.main)
matplot(rowSums(abs(Path))/max(rowSums(abs(Path))),Path,type="l",ylab=ylab.text,xlab=xlab.text,main="Enet with penalized",lwd=size.width)
abline(v=sum(abs(coef(opt$fullfit)[-1]))/sum(abs(Path[1, ])))
axis(4, at = Path[1, ], labels = colnames(X), adj = 0, las = 1,cex.axis=size.right)

@

LASSO mit penalized

<<results=hide,eval=FALSE>>=

Path<-matrix(0,60,p)
lambda1<-exp(seq(-10, 6, length = 60))
lambda2 = 0

for(i in 60:1)
{
Path[i,]<-coef(penalized (y,penalized=X.std/sqrt(n), lambda1 = lambda1[i], lambda2 = lambda2,model="logistic",standardize=FALSE),"penalized")
}
opt <- optL1(y,penalized=X.std/sqrt(n), lambda2 = lambda2,model="logistic",standardize=FALSE,fold=fold.vec)

@
<<fig=TRUE,eval=FALSE>>=

par(oma=oma.vec,cex.axis=size.axis,cex.lab=size.axis,cex.main=size.main)
matplot(rowSums(abs(Path))/max(rowSums(abs(Path))),Path,type="l",ylab=ylab.text,xlab=xlab.text,main="Lasso with penalized",lwd=size.width)
abline(v=sum(abs(coef(opt$fullfit)[-1]))/sum(abs(Path[1, ])))
axis(4, at = Path[1, ], labels = colnames(X), adj = 0, las = 1,cex.axis=size.right)

@

\end{document}